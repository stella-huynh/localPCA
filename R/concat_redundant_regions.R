options(warn = 2)

concatReg <- function(tab, rtab, listRegionH1, clustsize, corr_thr=0.6) {

  ###  tab : full raw table with values of all MDS and MDScr (center-reducted) for all genomic windows [tab]
  ###  rtab : table of outlier genomic regions assessed generated by the R-function "get_outlier_regions()" [tab_region]
  ###  listRegionH1 : list of oultier genomic regions with index of the outlier windows that are comprised in each of them [listRehionH1]
  ###  clustsize : minimum size of intersect portion (in number of windows) between two overlapping regions [nwin_cluster]
  ###  corr_thr : minimum threshold for correlation test [0.6]

  ###  Each genomic region is processed one after the other, by comparing it to the previous region(s). Each time the previous region overlap the current region, it is stored in the R-object "tmp" and will remain until it is concatenated or non-overlapping with the current region. The current region may therefore be compared with more than one previous region if these latter are still overlapping the current region but with no correlated MDS values (in such case they are not concatenated and kept separated). Once the current region does not overlap with a previous region, this latter will be removed from "tmp".
  ###  The previous region(s) is stored in "rtab_i0/rtab_i" and "tmp".
  ###  The current region is stored "rtab_j".

  rtab = rtab %>% mutate(chr = factor(chr, ordered=T, levels = unique(mixedsort(chr)))) %>% arrange(chr,start,end,desc(SizeRegions))

  tabF = data.frame(matrix(ncol=8,nrow=0))
  colnames(tabF) = c("nID",colnames(rtab))
  to_remove = list() #list of genomic regions' IDs judged as redundant and therefore to be ignored in final table.

  count=0 #used as IDs for the final concatenated region
  tmp=NULL


  for(n in 2:nrow(rtab)) {

    merged_IDs = NULL
    intersect_IDs = NULL

    if(is.null(tmp)) {
      rtab_i0 = rtab[n-1,] #compare to single previous region
    } else {
      rtab_i0 = tmp #compare to all the accumulated overlapping previous regionS
    }
    rtab_j = rtab[n,]

    rtab_i_IDs = rtab_i0[,"ID"]

    for(m in rtab_i_IDs) {

      rtab_i = rtab_i0[which(rtab_i0$ID==m),]
      chr_i = rtab_i$chr
      chr_j = rtab_j$chr

      if(!(rtab_i[,"ID"] %in% to_remove)) {

        #if windows pair are on the same chromosome
        if(chr_i == chr_j) {

          MDS_i   = rtab_i$MDS
          MDS_j   = rtab_j$MDS
          start_i = rtab_i$start
          start_j = rtab_j$start
          end_i   = rtab_i$end
          end_j   = rtab_j$end

          # Nested windows
          # case1 : MDSa1 > MDSa2
          if ((start_i <= start_j) && (end_i >= end_j)) { do_clust=TRUE ; case=1
          # case2 : MDSa2 > MDSa1
          } else if ((start_j <= start_i) && (end_j >= end_i)) { do_clust=TRUE ; case=2
          # Overlapping windows
          # case3 : MDSa1_end overlap MDSa2_start
          } else if ((start_i <= start_j) && (start_j <= end_i) && (end_j >= end_i)) { do_clust=TRUE ; case=3
          # case4 : MDSa1_start overlap MDSa2_end
          } else if ((start_j <= start_i) && (start_i <= end_j) && (end_i >= end_j)) { do_clust=TRUE ; case=4
          #no overlap
          } else { do_clust=FALSE ; case=NA
          }

          #Correlation test (if overlapping windows pair)
          if(do_clust==TRUE) {

            ID_i = rtab_i$ID
            ID_j = rtab_j$ID
            if(is.character(ID_i)){
              outliers_i = unique(sort(unlist(listRegionH1[as.numeric(unlist(strsplit(ID_i,",|/")))]))) #extract indexes of the windows comprised in the genomic region rtab_i (for concatenated previous regions)
            } else {
              outliers_i = unlist(listRegionH1[ID_i]) #extract indexes of the windows comprised in the genomic region rtab_i (for single previous region)
            }
            outliers_j = unlist(listRegionH1[ID_j]) #extract indexes of the windows comprised in the genomic region rtab_j
            firstpos_i = outliers_i[1] #extract position of the first window (ie. beginning of the region)
            firstpos_j = outliers_j[1] #extract position of the first window
            lastpos_i  = rev(outliers_i)[1]
            lastpos_j  = rev(outliers_j)[1]

            corrmat_i = tab %>% filter((ID>=firstpos_i)&(ID<=lastpos_i)) %>% dplyr::select(all_of(MDS_i),all_of(MDS_j))  #extract MDS values of those windows for region rtab_i
            corrmat_j = tab %>% filter((ID>=firstpos_j)&(ID<=lastpos_j)) %>% dplyr::select(all_of(MDS_i),all_of(MDS_j))  #extract MDS values of those windows for region rtab_i
            mcor_i = cor(corrmat_i, method="pearson") #correlation test for MDS values within rtab_i region coordinates
            mcor_j = cor(corrmat_j, method="pearson") #correlation test for MDS values within rtab_j region coordinates
            if(MDS_i == MDS_j) {
              rcor_i = mcor_i[1] ; rcor_j = mcor_j[1]
            } else {
              rcor_i = mcor_i[2] ; rcor_j = mcor_j[2]
            }

            rcorr = mean(c(abs(rcor_i),abs(rcor_j))) #Pearson correlation. A value of 0 implies that there is no linear dependency between the two regions. An absolute value of 1 implies a linear equation describing the relationship between the two regions.

            #if significant correlation ...
            if ( abs(rcor_j) > corr_thr || abs(rcor_i) > corr_thr ) {

              if(case==1) { # --> keep ID_i and remove ID_j
                to_remove = append(to_remove, ID_j)
                if(is.null(tmp)) {
                  tmp = rtab_i
                }

              } else if(case==2) { # ---> keep ID_j and remove ID_i
                to_remove = append(to_remove, ID_i)
                if(is.null(tmp)) {
                  tmp = rtab_j
                } else {
                  tmp = rbind(tmp,rtab_j)
                }

              } else if(case==3) { # --> merge ID_i + ID_j regions. Keep MDS values of the longest region of them two. For that a new region row needs to be created and added to the final result table..
                if(!is.null(tmp)) {
                  if(nrow(tmp)>1) { merged_IDs = c(merged_IDs, c(ID_i,ID_j)) }
                }
                if((end_i-start_i) > (end_j-start_j)) {
                  MDS_ij = MDS_i
                } else {
                  MDS_ij = MDS_j
                }
                new_region = data.frame(ID=paste0(ID_i,",",ID_j), MDS=MDS_ij, chr=chr_j, start=start_i, end=end_j, noutliers=length(union(outliers_i,outliers_j)), SizeRegions=round((end_j-start_i)/1000000,1))
                if(is.null(tmp) || nrow(tmp)==1) {
                  tmp = new_region
                } else {
                  tmp[which(tmp$ID==m),] = new_region
                }

              } else if(case==4) { # --> same as for case 3.
                if(!is.null(tmp)) {
                  if(nrow(tmp)>1) { merged_IDs = c(merged_IDs, c(ID_i,ID_j)) }
                }
                if((end_i-start_i) > (end_j-start_j)) {
                  MDS_ij = MDS_i
                } else {
                  MDS_ij = MDS_j
                }
                new_region = data.frame(ID=paste0(ID_i,",",ID_j), MDS=MDS_ij, chr=chr_j, start=start_j, end=end_i, noutliers=length(union(outliers_i,outliers_j)), SizeRegions=round((end_i-start_j)/1000000,1))
                if(is.null(tmp) || nrow(tmp)==1) {
                  tmp = new_region
                } else {
                  tmp[m,] = new_region
                }
              }

              #... else if size overlap > "clustsize" windows ; do corr-test for large intersect only
            } else {
              intersect_ij = intersect( seq(firstpos_i,lastpos_i), seq(firstpos_j,lastpos_j) )

              if(length(intersect_ij) >= clustsize) {

                if(case==1) {
                  corrmat_ij = tab %>% filter((ID>=firstpos_j)&(ID<=lastpos_j)) %>% dplyr::select(all_of(MDS_i),all_of(MDS_j))
                } else if(case==2) {
                  corrmat_ij = tab %>% filter((ID>=firstpos_i)&(ID<=lastpos_i)) %>% dplyr::select(all_of(MDS_i),all_of(MDS_j))
                } else if(case==3) {
                  corrmat_ij = tab %>% filter((ID>=firstpos_j)&(ID<=lastpos_i)) %>% dplyr::select(all_of(MDS_i),all_of(MDS_j))
                } else if(case==4) {
                  corrmat_ij = tab %>% filter((ID>=firstpos_i)&(ID<=lastpos_j)) %>% dplyr::select(all_of(MDS_i),all_of(MDS_j))
                }

                mcor_ij = cor(corrmat_ij, method="pearson")
                if(MDS_i == MDS_j) {
                  rcor_ij = mcor_ij[1]
                } else {
                  rcor_ij = mcor_ij[2]
                }

                if( abs(rcor_ij) > corr_thr ) {
                  if(!is.null(tmp)) {
                    if(nrow(tmp)>1) { intersect_IDs = c(intersect_IDs, c(ID_i,ID_j)) }
                  }

                  if(case==1) { # --> keep both ID_i and ID_j regions separate AND the correlated intersect between them. Keep MDS value of the longest region (here ID_i).
                    new_region = data.frame(ID=paste0(ID_i,"/",ID_j), MDS=MDS_ij, chr=chr_j, start=start_j, end=end_j, noutliers=length(intersect(outliers_i,outliers_j)), SizeRegions=rtab_j[,"SizeRegions"])

                  } else if(case==2) { # --> keep both ID_i and ID_j regions separate AND the correlated intersect between them. Keep MDS value of the longest region (here ID_j).
                    new_region = data.frame(ID=paste0(ID_i,"/",ID_j), MDS=MDS_ij, chr=chr_j, start=start_i, end=end_i, noutliers=length(intersect(outliers_i,outliers_j)), SizeRegions=rtab_i[,"SizeRegions"])

                  } else if(case==3) { # --> keep both ID_i and ID_j regions separate AND the correlated intersect between them. Keep MDS value of the longest region (either ID_i or ID_j).
                    if((end_i-start_i) > (end_j-start_j)) {
                      MDS_ij = MDS_i
                    } else {
                      MDS_ij = MDS_j
                    }
                    new_region = data.frame(ID=paste0(ID_i,"/",ID_j), MDS=MDS_ij, chr=chr_j, start=start_j, end=end_i, noutliers=length(intersect(outliers_i,outliers_j)), SizeRegions=round((end_i-start_j)/1000000,1))

                  } else if(case==4) { # --> keep both ID_i and ID_j regions separate AND the correlated intersect between them. Keep MDS value of the longest region (either ID_i or ID_j).
                    if((end_i-start_i) > (end_j-start_j)) {
                      MDS_ij = MDS_i
                    } else {
                      MDS_ij = MDS_j
                    }
                    new_region = data.frame(ID=paste0(ID_i,"/",ID_j), MDS=MDS_ij, chr=chr_j, start=start_i, end=end_j, noutliers=length(intersect(outliers_i,outliers_j)), SizeRegions=round((end_j-start_i)/1000000,1))
                  }

                  tmp = rbind(tmp, new_region, rtab_j)

                } else {

                  if(is.null(tmp)) {
                    tmp = rtab[(n-1):n,]
                  } else if(!(rtab[n,"ID"] %in% to_remove)) {
                    tmp = rbind(tmp, rtab[n,])
                  }

                }

              } else {

                if(is.null(tmp)) {
                  tmp = rtab[(n-1):n,]
                } else if(!(rtab[n,"ID"] %in% to_remove)) {
                  tmp = rbind(tmp, rtab[n,])
                }

              }
            }

          } else if(do_clust==FALSE) {

            if(is.character(tmp[,"ID"])) {
              tmp_IDs = as.numeric(unlist(strsplit(tmp[,"ID"],",|/")))
            } else {
              tmp_IDs = tmp[,"ID"]
            }

            if(!rtab_j["ID"] %in% tmp_IDs) {

              if(!is.null(tmp)) {

                if(is.character(m)) {
                  m_IDs = as.numeric(unlist(strsplit(m,",|/")))
                } else {
                  m_IDs = m
                }
                m_tmp = tmp[grep(paste0("\\b",m_IDs,"\\b",collapse="|"),tmp[,"ID"]),]

                # if non-overlapping regions are included in other merged regions that are overlapping the current region (rtab_j);
                # remove non-overlapping regions from tmp

                # ... remove non-overlapping regions from tmp
                if(nrow(m_tmp[which(m_tmp$end >= rtab_j$start),]) > 0) {
                  to_remove = append(to_remove, m_tmp[which(m_tmp$end < rtab_j$start),"ID"])

                  # ... otherwise keep longest one if several regions are overlapping each other but not the current region (rtab_j)
                } else {
                  m_tmp = m_tmp[which(m_tmp$end < rtab_j$start),]
                  m_tmp_IDs = m_tmp[,"ID"]
                  if(nrow(m_tmp)>1) { #if more than one region, keep longest one
                    m_tmp = m_tmp[which(m_tmp$SizeRegions==max(m_tmp$SizeRegions)),]
                    if(nrow(m_tmp)>1) { #if more than one region have same max_length, keep the one that has the highest number of outlier windows
                      m_tmp = m_tmp[which(m_tmp$noutliers==max(m_tmp$noutliers)),]
                      if(nrow(m_tmp)>1) { #if more than one region have same max_length and same number of outlier windows, just pick the first one
                        m_tmp = m_tmp[1,]
                      }
                    }
                  }

                  to_remove = append(to_remove, m_tmp_IDs[which(m_tmp_IDs!=m_tmp[,"ID"])])
                  rm(m_tmp_IDs)
                }

                if(nrow(m_tmp)==1) {

                  count = count + 1
                  tabF = rbind(tabF, cbind(nID=count, m_tmp))

                  if(m==tail(rtab_i_IDs,1)) {
                    tmp = NULL
                  } else {
                    tmp = tmp[which(tmp$ID != m),]
                  }

                } else if (nrow(m_tmp)==0) {
                  print(paste0("[",n,",",m,"] !! ISSUE : tmp is unexpectedly empty !!"))
                }
                rm(m_tmp)

              } else {

                count = count + 1
                tabF = rbind(tabF, cbind(nID=count, rtab[n-1,]))

              }

            }

          }

        #if different chromosome
        } else {

          count = count + 1

          if(!is.null(tmp)) {
            tabF = rbind(tabF, cbind(nID=count, rtab_i))
            if(m==tail(rtab_i_IDs,1)) { tmp = NULL } #once all regions in tmp have been processed, reset "tmp" to NULL.

          } else {
            tabF = rbind(tabF, cbind(nID=count, rtab[n-1,]))
          }

        }

      }

    }


    if(!is.null(tmp)) {

      if(m==tail(rtab_i_IDs,1)) {
        tmp = tmp[which(!tmp$ID %in% to_remove),]

        if(nrow(tmp)>0) {

          if(any(duplicated(tmp[,"ID"]))) {
            dup_IDs = as.numeric(tmp[,"ID"][duplicated(tmp[,"ID"])])
            tmp = tmp[!duplicated(tmp[,"ID"]),]
          }

          # remove region that got added to tmp if it has been later merged to another region in tmp
          if(is.character(tmp[,"ID"])) {

            if(any(duplicated(unlist(strsplit(tmp[,"ID"],","))))) {

              dup_IDs = unique(unlist(strsplit(tmp[,"ID"],","))[duplicated(unlist(strsplit(tmp[,"ID"],",")))])
              tmp = tmp[which(!as.character(tmp[,"ID"]) %in% dup_IDs),]

              if(nrow(tmp[grep(paste0("\\b",dup_IDs,"\\b",collapse="|"), tmp[,"ID"]),])>0) {
                cat(paste0("COMMENT : Removed region(s) [",dup_IDs,"] from tmp because it was/were found merged with other region(s) in tmp. \nNew tmp:\n")) ; print(tmp)
              } else {
                cat(paste0("ERROR : check row ",n,", IDs [",dup_IDs,"]."))
              }

            }

          }

          # re-merge merged regions containing common IDs
          if(any(duplicated(merged_IDs))) {
            dup_rows = tmp[grepl(paste0("\\b",merged_IDs[duplicated(merged_IDs)],"\\b",collapse="|"), tmp[,"ID"]),]

            if(nrow(dup_rows[which(dup_rows$start==min(dup_rows$start) & dup_rows$end==max(dup_rows$end)),])>0) {
              new_region = dup_rows[which(dup_rows$start==min(dup_rows$start) & dup_rows$end==max(dup_rows$end)),]

            } else {
              dup_IDs = paste0(unique(unlist(strsplit(dup_rows[,"ID"],","))),collapse=",")
              MDS_ij = unique(dup_rows[which(dup_rows$SizeRegions==min(dup_rows$SizeRegions)),"MDS"])
              noutliers = length(unlist(listRegionH1[as.numeric(unique(unlist(strsplit(dup_rows[,"ID"],",|/"))))]))
              new_region = data.frame(ID=dup_IDs, MDS=MDS_ij, chr=chr_j, start=min(dup_rows$start), end=max(dup_rows$end), noutliers=noutliers, SizeRegions=round((max(dup_rows$end)-min(dup_rows$start))/1000000,1))
            }
            tmp = rbind(new_region,tmp[!grepl(paste0("\\b",merged_IDs[duplicated(merged_IDs)],"\\b",collapse="|"), tmp[,"ID"]),])

          }

        } else {
          tmp = NULL
        }

      }

    } else {
      to_remove = list()
    }

  }

  # when reaching end of the "raw" region table, concatenate the last remaining region.
  if(n==nrow(rtab)) {

    count = count + 1

    if(is.character(tmp[,"ID"])) { tmp_IDs = unique(as.numeric(unlist(strsplit(tmp[,"ID"],",|/")))) } else { tmp_IDs = tmp[,"ID"] }
    if(is.character(tabF[,"ID"])) { tabF_IDs = unique(as.numeric(unlist(strsplit(tabF[,"ID"],",|/")))) } else { tabF_IDs = tabF[,"ID"] }

    if(any(!rtab_j$ID %in% tmp_IDs) && any(!rtab_j$ID %in% tabF_IDs)) {
      tmp = rbind(tmp,rtab[n,])
    }

    tabF = rbind(tabF, cbind(nID=count, tmp))
  }


  return(list(tabF=tabF, to_remove=to_remove))

}


